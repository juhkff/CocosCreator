# Cocos学习笔记 #


----------
2020/6/13 22:49:21 
## 制作第一个游戏 ##

Cocos Creator 中脚本名称就是组件的名称，这个命名是大小写敏感的！如果组件名称的大小写不正确，将无法正确通过名称使用组件！

cc 是 Cocos 的简称，Cocos 引擎的主要命名空间，引擎代码中所有的类、函数、属性和常量都在这个命名空间中定义。

onLoad写成onload检查了半天最后都把错误精确到行了都没发现，硬排bug排了一个半小时，还是靠换了个编辑器发现高亮提示才看出区别来。我的眼睛可能确实是瞎了。

**Prefab 资源**

组件可以暂存组件属性中未定义的对象.比如newstar资源的Star组件中并没有设置game属性，但我们仍可指定newStar.getComponent('Star').game = this;


Node 下的 `getPosition()` 方法 返回的是节点在**父节点**坐标系中的位置（x, y）



`cc.director` 是一个管理你的游戏逻辑流程的单例对象。由于 `cc.director` 是一个**单例**


我们再注意到这个方法的返回值 —— `ActionInstant`，这是一个瞬间执行的动作类。到这里我们就可以理解了，使用 `callFunc` 调用回调函数可以让函数转变为 `cc` 中的 `Action`（动作），这一用法在 `cc` 的动作系统里非常实用！例如在上面我们将播放声音的函数传入 `callFunc` 赋值给 `callback`，让 `callback` 成为了一个播放声音的动作 `Action`，那么我们之后就能通过 `cc.sequence` 将跳跃和播放声音的动作组合起来，实现每跳一次就能播放音效的功能！

序列化和反序列化支持 Cocos Creator 中类的绝大多数公有属性，这些属性通过属性检查器面板暴露给开发者。开发者可以在编辑器中随意修改并保存，保存的过程就是将资源和场景数据序列化到资源数据库（Asset Database）中。反之，在加载场景的过程中，反序列化机制会根据场景数据实例化相应的对象，并加载编辑器中设置的所有属性。也就是说，序列化会将这些修改后的属性保存到场景中。而反序列化是每次启动场景的时候，这些属性都会被加载。


----------

2020/6/14 1:55:02  

## 资源工作流程 ##
**资源配置文件（.meta）** 这份配置文件提供了该资源在项目中的唯一标识（uuid）以及其他的一些配置信息（如图集中的小图引用，贴图资源的裁剪数据等），非常重要。
在编辑器中管理资源时，meta 文件是不可见的，对资源的任意删除、改名、移动操作，都会由编辑器自动同步相应的 meta 文件，确保 uuid 的引用不会丢失和错乱。

**注意在编辑器外部的文件系统中（Explorer，Finder）对资源文件进行删除、改名、移动时必须同步处理相应的 meta 文件。** 资源文件和其对应的 meta 文件应该保持在同一个目录下，而且文件名相同。

**修改场景资源自动释放策略**<br>
>已知问题：粒子系统的 plist 所引用的贴图不会被自动释放。如果要自动释放粒子贴图，请从 plist 中移除贴图信息，改用粒子组件的 Texture 属性来指定贴图。

只有场景能够自动释放资源

**防止特定资源被自动释放**<br>
启用了某个场景的资源自动释放后，如果在脚本中保存了对该场景的资源的 **“特殊引用”**，则当场景切换后，由于资源已经被释放，这些引用可能会变成非法的，有可能引起渲染异常等问题。为了让这部分资源在场景切换时不被释放，我们可以使用 `cc.loader.setAutoRelease` 或者 `cc.loader.setAutoReleaseRecursively` 来保留这些资源。

>“特殊引用”指的是以全局变量、单例、闭包、“特殊组件”、“动态资源”等形式进行的引用。

***拓展：单例模式：***

（具体学习内容记录在OneNote中）


----------
